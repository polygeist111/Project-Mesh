


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Kover HTML Report Coverage Report > DeviceStatusManager</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope: Kover HTML Report<span class="separator">|</span>    <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">release.com.greybox.projectmesh</a>
</div>

<h1>Coverage Summary for Class: DeviceStatusManager (release.com.greybox.projectmesh)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
<th class="coverageStat 
">
  Instruction, %
</th>
</tr>
  <tr>
    <td class="name">DeviceStatusManager$startPeriodicStatusChecks$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">DeviceStatusManager$updateConversations$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/100)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DeviceStatusManager$verifyDeviceStatus$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">DeviceStatusManager$verifyDeviceStatus$1$isReachable$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/116)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.greybox.projectmesh
&nbsp;
&nbsp;import android.util.Log
&nbsp;import com.greybox.projectmesh.server.AppServer
&nbsp;import kotlinx.coroutines.CoroutineScope
&nbsp;import kotlinx.coroutines.Dispatchers
&nbsp;import kotlinx.coroutines.Job
&nbsp;import kotlinx.coroutines.delay
&nbsp;import kotlinx.coroutines.flow.MutableStateFlow
&nbsp;import kotlinx.coroutines.flow.StateFlow
&nbsp;import kotlinx.coroutines.flow.asStateFlow
&nbsp;import kotlinx.coroutines.flow.update
&nbsp;import kotlinx.coroutines.launch
&nbsp;import kotlinx.coroutines.withTimeoutOrNull
&nbsp;import java.net.InetAddress
&nbsp;
&nbsp;/**
&nbsp; * Centralized manager for tracking online/offline status of devices.
&nbsp; * This singleton provides a single source of truth that can be observed by different parts of the app.
&nbsp; */
&nbsp;
&nbsp;object DeviceStatusManager {
&nbsp;    //private mutable state flow that stores device IP address to online status mapping
&nbsp;    private val _deviceStatusMap = MutableStateFlow&lt;Map&lt;String, Boolean&gt;&gt;(emptyMap())
&nbsp;
&nbsp;    //public read only state flow for detection
&nbsp;    val deviceStatusMap: StateFlow&lt;Map&lt;String, Boolean&gt;&gt; = _deviceStatusMap.asStateFlow()
&nbsp;
&nbsp;    // min time between status checks
&nbsp;    private const val MIN_STATUS_CHECK_INTERVAL = 5000L
&nbsp;
&nbsp;    //map to track when a device was last checked
&nbsp;    private val lastCheckedTimes = mutableMapOf&lt;String, Long&gt;()
&nbsp;
&nbsp;    //coroutine scope for background operations
&nbsp;    private val scope = CoroutineScope(Dispatchers.IO + Job())
&nbsp;
&nbsp;    //reference to AppServer - will be set during initialization
&nbsp;    private var appServer: AppServer? = null
&nbsp;
&nbsp;    //track consecutive failures
&nbsp;    private val failureCountMap = mutableMapOf&lt;String, Int&gt;()
&nbsp;
&nbsp;    //special test device addresses that should be handled differently
&nbsp;    private val specialDevices = setOf(
&nbsp;        &quot;192.168.0.99&quot;,  // Online test device
&nbsp;        &quot;192.168.0.98&quot;   // Offline test device
&nbsp;    )
&nbsp;
&nbsp;    //initialize the device status manager with necessary dependencies
&nbsp;    fun initialize(server: AppServer) {
&nbsp;        appServer = server
&nbsp;
&nbsp;        // Start periodic background checks
&nbsp;        startPeriodicStatusChecks()
&nbsp;    }
&nbsp;
&nbsp;    fun updateDeviceStatus(ipAddress: String, isOnline: Boolean, verified: Boolean = false) {
&nbsp;        //if this is a special device, handle according to its predefined status
&nbsp;        if (ipAddress == &quot;192.168.0.99&quot;) { // Online test device
&nbsp;            _deviceStatusMap.update { current -&gt;
&nbsp;                val mutable = current.toMutableMap()
&nbsp;                mutable[ipAddress] = true
&nbsp;                mutable
&nbsp;            }
&nbsp;            Log.d(&quot;DeviceStatusManager&quot;, &quot;Updated test device status for $ipAddress: online&quot;)
&nbsp;            return
&nbsp;        } else if (ipAddress == &quot;192.168.0.98&quot;) { // Offline test device
&nbsp;            _deviceStatusMap.update { current -&gt;
&nbsp;                val mutable = current.toMutableMap()
&nbsp;                mutable[ipAddress] = false
&nbsp;                mutable
&nbsp;            }
&nbsp;            Log.d(&quot;DeviceStatusManager&quot;, &quot;Updated test device status for $ipAddress: offline&quot;)
&nbsp;            return
&nbsp;        }
&nbsp;
&nbsp;        //for normal devices, if the update is verified (from a trusted component), update immediately
&nbsp;        if (verified) {
&nbsp;            _deviceStatusMap.update { current -&gt;
&nbsp;                val mutable = current.toMutableMap()
&nbsp;                mutable[ipAddress] = isOnline
&nbsp;                Log.d(&quot;DeviceStatusManager&quot;, &quot;Updated verified status for $ipAddress: ${if (isOnline) &quot;online&quot; else &quot;offline&quot;}&quot;)
&nbsp;                mutable
&nbsp;            }
&nbsp;            //also update the last checked time
&nbsp;            lastCheckedTimes[ipAddress] = System.currentTimeMillis()
&nbsp;        } else {
&nbsp;            //if not verified, only change offline-&gt;online (we&#39;ll verify before changing online-&gt;offline)
&nbsp;            if (isOnline &amp;&amp; (!_deviceStatusMap.value.containsKey(ipAddress) || _deviceStatusMap.value[ipAddress] == false)) {
&nbsp;                // Only update if we&#39;re going from offline/unknown to online
&nbsp;                _deviceStatusMap.update { current -&gt;
&nbsp;                    val mutable = current.toMutableMap()
&nbsp;                    mutable[ipAddress] = true
&nbsp;                    Log.d(&quot;DeviceStatusManager&quot;, &quot;Updated status for $ipAddress: online (unverified)&quot;)
&nbsp;                    mutable
&nbsp;                }
&nbsp;
&nbsp;                //schedule a verification check to confirm it&#39;s really online
&nbsp;                verifyDeviceStatus(ipAddress)
&nbsp;            } else if (!isOnline) {
&nbsp;                //for marking devices offline, we need verification
&nbsp;                verifyDeviceStatus(ipAddress)
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    //check if a device is currently online
&nbsp;    fun isDeviceOnline(ipAddress: String): Boolean {
&nbsp;        // Check if it&#39;s time to verify this device again
&nbsp;        val lastChecked = lastCheckedTimes[ipAddress] ?: 0L
&nbsp;        val now = System.currentTimeMillis()
&nbsp;
&nbsp;        if (now - lastChecked &gt; MIN_STATUS_CHECK_INTERVAL &amp;&amp;
&nbsp;            _deviceStatusMap.value[ipAddress] == true) {
&nbsp;            // If it&#39;s been a while since we checked and device is marked online, verify
&nbsp;            verifyDeviceStatus(ipAddress)
&nbsp;        }
&nbsp;
&nbsp;        return _deviceStatusMap.value[ipAddress] ?: false
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    //verify if a device is actually online by attempting to connect
&nbsp;    fun verifyDeviceStatus(ipAddress: String) {
&nbsp;        // Skip verification for special test devices
&nbsp;        if (ipAddress in specialDevices) {
&nbsp;            return
&nbsp;        }
&nbsp;
&nbsp;        // Check if we&#39;ve verified recently
&nbsp;        val lastChecked = lastCheckedTimes[ipAddress] ?: 0L
&nbsp;        val now = System.currentTimeMillis()
&nbsp;
&nbsp;        if (now - lastChecked &lt; MIN_STATUS_CHECK_INTERVAL) {
&nbsp;            // Checked too recently, skip
&nbsp;            return
&nbsp;        }
&nbsp;
&nbsp;        scope.launch {
&nbsp;            // Add a log to track verification attempts
&nbsp;            Log.d(&quot;DeviceStatusManager&quot;, &quot;Verifying device status for $ipAddress&quot;)
&nbsp;
&nbsp;            lastCheckedTimes[ipAddress] = System.currentTimeMillis()
&nbsp;
&nbsp;            try {
&nbsp;                // IMPORTANT: Check if there are any recent messages from this device
&nbsp;                // This information is maintained in NetworkScreenViewModel
&nbsp;                // We can check if the IP is in the current known nodes list
&nbsp;
&nbsp;                // Instead of directly accessing originatorMessages, we&#39;ll use the current
&nbsp;                // deviceStatusMap to see if the device was marked as online by any component
&nbsp;                val isCurrentlyOnline = _deviceStatusMap.value[ipAddress] ?: false
&nbsp;
&nbsp;                // If the device was marked as online by any component and we&#39;re doing
&nbsp;                // a verification check, give it more attempts before marking offline
&nbsp;                val attemptsNeeded = if (isCurrentlyOnline) 3 else 1
&nbsp;
&nbsp;                val addr = InetAddress.getByName(ipAddress)
<b class="nc">&nbsp;                val isReachable = withTimeoutOrNull(3000) {</b>
<b class="nc">&nbsp;                    addr.isReachable(2000)</b>
&nbsp;                } ?: false
&nbsp;
&nbsp;                if (isReachable) {
&nbsp;                    // Reset failure count if reachable
&nbsp;                    failureCountMap.remove(ipAddress)
&nbsp;
&nbsp;                    // Update status to online
&nbsp;                    _deviceStatusMap.update { current -&gt;
&nbsp;                        val mutable = current.toMutableMap()
&nbsp;                        mutable[ipAddress] = true
&nbsp;                        Log.d(&quot;DeviceStatusManager&quot;, &quot;Device $ipAddress is reachable, marking online&quot;)
&nbsp;                        mutable
&nbsp;                    }
&nbsp;                } else {
&nbsp;                    // Not reachable - increment failure count
&nbsp;                    val failures = (failureCountMap[ipAddress] ?: 0) + 1
&nbsp;                    failureCountMap[ipAddress] = failures
&nbsp;
&nbsp;                    // Only mark as offline after multiple consecutive failures
&nbsp;                    if (failures &gt;= attemptsNeeded) {
&nbsp;                        _deviceStatusMap.update { current -&gt;
&nbsp;                            val mutable = current.toMutableMap()
&nbsp;                            mutable[ipAddress] = false
&nbsp;                            Log.d(&quot;DeviceStatusManager&quot;,
&nbsp;                                &quot;Device $ipAddress is unreachable after $failures attempts, marking offline&quot;)
&nbsp;                            mutable
&nbsp;                        }
&nbsp;                    } else {
&nbsp;                        Log.d(&quot;DeviceStatusManager&quot;,
&nbsp;                            &quot;Device $ipAddress is unreachable (attempt $failures/$attemptsNeeded), still considered online&quot;)
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                // Then try the app-level check if the device is believed to be online
&nbsp;                if (isReachable || (isCurrentlyOnline &amp;&amp; failureCountMap[ipAddress] ?: 0 &lt; attemptsNeeded)) {
&nbsp;                    appServer?.let { server -&gt;
&nbsp;                        // Only do this check if we have the AppServer instance
&nbsp;                        try {
&nbsp;                            // Try a quick check to app server endpoints
&nbsp;                            val checkResult = server.checkDeviceReachable(addr)
&nbsp;
&nbsp;                            if (checkResult) {
&nbsp;                                // Reset failure count on successful app-level check
&nbsp;                                failureCountMap.remove(ipAddress)
&nbsp;
&nbsp;                                _deviceStatusMap.update { current -&gt;
&nbsp;                                    val mutable = current.toMutableMap()
&nbsp;                                    mutable[ipAddress] = true
&nbsp;                                    Log.d(&quot;DeviceStatusManager&quot;,
&nbsp;                                        &quot;App-level check for $ipAddress successful, marking online&quot;)
&nbsp;                                    mutable
&nbsp;                                }
&nbsp;
&nbsp;                                // If device is online, update user info and conversation status
&nbsp;                                server.requestRemoteUserInfo(addr)
&nbsp;                            }else {
&nbsp;                                //do nothing
&nbsp;                            }
&nbsp;                        } catch (e: Exception) {
&nbsp;                            // Log but don&#39;t immediately change status based on this check
&nbsp;                            Log.d(&quot;DeviceStatusManager&quot;, &quot;App-level check for $ipAddress failed: ${e.message}&quot;)
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            } catch (e: Exception) {
&nbsp;                // If any exception occurs, log but don&#39;t immediately mark as offline
&nbsp;                Log.d(&quot;DeviceStatusManager&quot;, &quot;Error checking device $ipAddress: ${e.message}&quot;)
&nbsp;
&nbsp;                // Increment failure count
&nbsp;                val failures = (failureCountMap[ipAddress] ?: 0) + 1
&nbsp;                failureCountMap[ipAddress] = failures
&nbsp;
&nbsp;                // Mark as offline after 3 consecutive failures
&nbsp;                if (failures &gt;= 3) {
&nbsp;                    _deviceStatusMap.update { current -&gt;
&nbsp;                        val mutable = current.toMutableMap()
&nbsp;                        mutable[ipAddress] = false
&nbsp;                        Log.d(&quot;DeviceStatusManager&quot;,
&nbsp;                            &quot;Device $ipAddress has $failures consecutive failures, marking offline&quot;)
&nbsp;                        mutable
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    fun handleNetworkDisconnect(ipAddress: String) {
&nbsp;        Log.d(&quot;DeviceStatusManager&quot;, &quot;Network layer reported disconnect for $ipAddress, immediately updating status&quot;)
&nbsp;
&nbsp;        // Skip for special test devices
&nbsp;        if (ipAddress in specialDevices) {
&nbsp;            return
&nbsp;        }
&nbsp;
&nbsp;        // Immediately update status to offline
&nbsp;        _deviceStatusMap.update { current -&gt;
&nbsp;            val mutable = current.toMutableMap()
&nbsp;            mutable[ipAddress] = false
&nbsp;            mutable
&nbsp;        }
&nbsp;
&nbsp;        // Reset failure count
&nbsp;        failureCountMap.remove(ipAddress)
&nbsp;
&nbsp;        // Update conversations immediately
&nbsp;        updateConversations(ipAddress, false)
&nbsp;    }
&nbsp;
&nbsp;    // Helper method to update conversations when device status changes
&nbsp;    private fun updateConversations(ipAddress: String, isOnline: Boolean) {
<b class="nc">&nbsp;        scope.launch {</b>
&nbsp;            try {
&nbsp;                // Get user by IP
<b class="nc">&nbsp;                val user = GlobalApp.GlobalUserRepo.userRepository.getUserByIp(ipAddress)</b>
<b class="nc">&nbsp;                if (user != null) {</b>
&nbsp;                    // Update conversation status
<b class="nc">&nbsp;                    GlobalApp.GlobalUserRepo.conversationRepository.updateUserStatus(</b>
<b class="nc">&nbsp;                        userUuid = user.uuid,</b>
<b class="nc">&nbsp;                        isOnline = isOnline,</b>
<b class="nc">&nbsp;                        userAddress = if (isOnline) ipAddress else null</b>
&nbsp;                    )
<b class="nc">&nbsp;                    Log.d(&quot;DeviceStatusManager&quot;, &quot;Updated conversation status for ${user.name}: online=$isOnline&quot;)</b>
&nbsp;                }
&nbsp;            } catch (e: Exception) {
<b class="nc">&nbsp;                Log.e(&quot;DeviceStatusManager&quot;, &quot;Error updating conversation for $ipAddress&quot;, e)</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    //get all online devices
&nbsp;    fun getOnlineDevices(): List&lt;String&gt; {
&nbsp;        return _deviceStatusMap.value.filter { it.value }.keys.toList()
&nbsp;    }
&nbsp;
&nbsp;    //clear all device statuses
&nbsp;    //use when restarting app or when network changes alot
&nbsp;    fun clearAllStatuses() {
&nbsp;        _deviceStatusMap.value = emptyMap()
&nbsp;        lastCheckedTimes.clear()
&nbsp;        Log.d(&quot;DeviceStatusManager&quot;, &quot;Cleared all device statuses&quot;)
&nbsp;    }
&nbsp;
&nbsp;    //Start periodic background checks for device status
&nbsp;    private fun startPeriodicStatusChecks() {
&nbsp;        scope.launch {
&nbsp;            while (true) {
&nbsp;                // Check all devices marked as online
&nbsp;                _deviceStatusMap.value.filter { it.value }.keys.forEach { ipAddress -&gt;
&nbsp;                    // Skip special devices
&nbsp;                    if (ipAddress !in specialDevices) {
&nbsp;                        verifyDeviceStatus(ipAddress)
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                // Wait between check cycles
&nbsp;                delay(30000) // 30 seconds between checks
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-12-02 05:53</div>
</div>
</body>
</html>
