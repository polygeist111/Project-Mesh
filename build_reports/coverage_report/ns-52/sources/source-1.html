


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Kover HTML Report Coverage Report > AppServer</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope: Kover HTML Report<span class="separator">|</span>    <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.greybox.projectmesh.server</a>
</div>

<h1>Coverage Summary for Class: AppServer (com.greybox.projectmesh.server)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Branch, %
</th>
</tr>
  <tr>
    <td class="name">AppServer$1</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">AppServer$onDeleteIncomingTransfer$2</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">AppServer$pushUserInfoTo$1</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">AppServer$requestRemoteUserInfo$1</td>
    <td class="coverageStat"/>
  </tr>
  <tr>
    <td class="name">AppServer$sendDeviceName$2</td>
    <td class="coverageStat"/>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
    <td class="coverageStat"/>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package com.greybox.projectmesh.server
&nbsp;
&nbsp;import android.app.NotificationManager
&nbsp;import android.app.PendingIntent
&nbsp;import android.content.Context
&nbsp;import android.content.Intent
&nbsp;import android.content.SharedPreferences
&nbsp;import android.net.Uri
&nbsp;import android.os.Build
&nbsp;import android.se.omapi.Session
&nbsp;import android.util.Log
&nbsp;import androidx.core.app.NotificationCompat
&nbsp;import com.google.gson.Gson
&nbsp;import com.greybox.projectmesh.DeviceStatusManager
&nbsp;import com.greybox.projectmesh.GlobalApp
&nbsp;import com.greybox.projectmesh.MainActivity
&nbsp;import com.greybox.projectmesh.R
&nbsp;import com.greybox.projectmesh.db.MeshDatabase
&nbsp;import com.greybox.projectmesh.messaging.data.entities.Message
&nbsp;import com.greybox.projectmesh.messaging.network.MessageNetworkHandler
&nbsp;import com.greybox.projectmesh.extension.updateItem
&nbsp;import com.greybox.projectmesh.testing.TestDeviceService
&nbsp;import com.ustadmobile.meshrabiya.ext.copyToWithProgressCallback
&nbsp;import com.ustadmobile.meshrabiya.util.FileSerializer
&nbsp;import com.ustadmobile.meshrabiya.util.InetAddressSerializer
&nbsp;import fi.iki.elonen.NanoHTTPD
&nbsp;import kotlinx.coroutines.CoroutineScope
&nbsp;import kotlinx.coroutines.Dispatchers
&nbsp;import kotlinx.coroutines.Job
&nbsp;import kotlinx.coroutines.cancel
&nbsp;import kotlinx.coroutines.delay
&nbsp;import kotlinx.coroutines.flow.Flow
&nbsp;import kotlinx.coroutines.flow.MutableStateFlow
&nbsp;import kotlinx.coroutines.flow.asStateFlow
&nbsp;import kotlinx.coroutines.flow.update
&nbsp;import kotlinx.coroutines.flow.updateAndGet
&nbsp;import kotlinx.coroutines.launch
&nbsp;import kotlinx.coroutines.withContext
&nbsp;import kotlinx.serialization.Serializable
&nbsp;import kotlinx.serialization.json.Json
&nbsp;import okhttp3.OkHttpClient
&nbsp;import okhttp3.Request
&nbsp;import okhttp3.internal.headersContentLength
&nbsp;import java.io.Closeable
&nbsp;import java.io.File
&nbsp;import java.io.FileOutputStream
&nbsp;import java.net.InetAddress
&nbsp;import java.net.URLEncoder
&nbsp;import java.util.concurrent.atomic.AtomicInteger
&nbsp;import com.greybox.projectmesh.extension.getUriNameAndSize
&nbsp;import com.greybox.projectmesh.messaging.data.entities.JSONSchema
&nbsp;import com.greybox.projectmesh.user.UserEntity
&nbsp;import com.greybox.projectmesh.user.UserRepository
&nbsp;import org.kodein.di.DI
&nbsp;import org.kodein.di.DIAware
&nbsp;import org.kodein.di.instance
&nbsp;import okhttp3.HttpUrl
&nbsp;import okhttp3.MediaType.Companion.toMediaType
&nbsp;import java.net.URLDecoder
&nbsp;import kotlinx.coroutines.runBlocking
&nbsp;import okhttp3.Call
&nbsp;import okhttp3.Callback
&nbsp;import okhttp3.MediaType.Companion.toMediaTypeOrNull
&nbsp;import okhttp3.RequestBody
&nbsp;//import okhttp3.RequestBody.Companion.toRequestBody
&nbsp;import okhttp3.Response
&nbsp;import java.io.IOException
&nbsp;import java.net.URI
&nbsp;import okhttp3.RequestBody.Companion.toRequestBody
&nbsp;import com.greybox.projectmesh.util.NotificationHelper
&nbsp;import com.ustadmobile.meshrabiya.log.MNetLogger
&nbsp;
&nbsp;/*
&nbsp;This File is the Server for transferring files
&nbsp;The Meshrabiya test app uses NanoHttpD as the server, OkHttp as the client
&nbsp;*/
&nbsp;class AppServer(
&nbsp;    private val appContext: Context,
&nbsp;    private val httpClient: OkHttpClient,   // OkHttp client for making HTTP requests
&nbsp;    private val mLogger: MNetLogger,
&nbsp;    name: String,
&nbsp;    port: Int = 0,  // Port for NanoHTTPD server, default is 0
&nbsp;    val localVirtualAddr: InetAddress,
&nbsp;    private val receiveDir: File,   // Directory for receiving files
&nbsp;    private val json: Json,
&nbsp;    private val db: MeshDatabase,
&nbsp;    override val di: DI,
&nbsp;    private val userRepository: UserRepository
&nbsp;) : NanoHTTPD(port), Closeable, DIAware {
&nbsp;
&nbsp;    private val logPrefix: String = &quot;[AppServer - $name] &quot;
&nbsp;
&nbsp;    private val scope = CoroutineScope(Dispatchers.IO + Job())
&nbsp;
&nbsp;    enum class Status {
&nbsp;        PENDING, IN_PROGRESS, COMPLETED, FAILED, DECLINED
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    private fun handleMyInfoRequest(): Response {
&nbsp;        val sharedPrefs: SharedPreferences by di.instance(tag = &quot;settings&quot;)
&nbsp;        val localUuid = sharedPrefs.getString(&quot;UUID&quot;, null) ?: return newFixedLengthResponse(
&nbsp;            Response.Status.INTERNAL_ERROR, &quot;application/json&quot;, &quot;&quot;&quot;{&quot;error&quot;:&quot;No local UUID found&quot;}&quot;&quot;&quot;
&nbsp;        )
&nbsp;
&nbsp;        val localUser = runBlocking { userRepository.getUser(localUuid) } ?: return newFixedLengthResponse(
&nbsp;            Response.Status.INTERNAL_ERROR, &quot;application/json&quot;, &quot;&quot;&quot;{&quot;error&quot;:&quot;No local user record in DB&quot;}&quot;&quot;&quot;
&nbsp;        )
&nbsp;
&nbsp;        // Add the local IP to the address field so it comes through in JSON
&nbsp;        val localUserWithAddr = localUser.copy(
&nbsp;            address = localVirtualAddr.hostAddress // or any IP you want to send
&nbsp;        )
&nbsp;
&nbsp;        val userJson = json.encodeToString(UserEntity.serializer(), localUserWithAddr)
&nbsp;        return newFixedLengthResponse(Response.Status.OK, &quot;application/json&quot;, userJson)
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    // Restart method to stop and start the server with an optional new IP address
&nbsp;    fun restart() {
&nbsp;        stop() // Stop the server using NanoHTTPD&#39;s built-in stop method
&nbsp;        Log.d(&quot;AppServer&quot;, &quot;Server stopped successfully&quot;)
&nbsp;        start(SOCKET_READ_TIMEOUT, false) // Start the server using NanoHTTPD&#39;s built-in start method
&nbsp;        Log.d(&quot;AppServer&quot;, &quot;Server restarted successfully on port: $localPort&quot;)
&nbsp;    }
&nbsp;
&nbsp;//change to json
&nbsp;    /*
&nbsp;    This data class contains all the information about the outgoing transfer (Sending a file)
&nbsp;    Why not using Serializable annotation?
&nbsp;    -&gt; Considering the use case of Outgoing Transfer, we only upload a file, and sending this file.
&nbsp;    -&gt; The file will be temporary stored in the local memory.
&nbsp;     */
&nbsp;    data class OutgoingTransferInfo(
&nbsp;        val id: Int,                          // Transfer ID
&nbsp;        val name: String,                     // Name of the file being sent
&nbsp;        val uri: Uri,                         // URI of the file to be sent
&nbsp;        val toHost: InetAddress,              // Destination address of the transfer
&nbsp;        val status: Status = Status.PENDING,  // Initial transfer status is PENDING
&nbsp;        val size: Int,                        // Size of the file in bytes
&nbsp;        val transferred: Int = 0,             // Bytes transferred so far
&nbsp;    )
&nbsp;
&nbsp;    /*
&nbsp;    This data class contains all the information about the incoming transfer (Receiving a file)
&nbsp;    By using Serializable annotation, The IncomingTransferInfo object will be serialized to JSON file,
&nbsp;    this will:
&nbsp;    1. persist the state of transfer, even if the app is closed or crashed
&nbsp;    2. be necessary for sending and receiving structured data over network
&nbsp;    Why there are two parameters (fromHost, file) use custom serializers?
&nbsp;    -&gt; These are complex types, Kotlin&#39;s serialization framework doesn&#39;t know how to serialize them.
&nbsp;    -&gt; The custom serializers are from Meshrabiya library.
&nbsp;    */
&nbsp;
&nbsp;    @Serializable
&nbsp;    data class IncomingTransferInfo(
&nbsp;        val id: Int,
&nbsp;        val requestReceivedTime: Long = System.currentTimeMillis(),
&nbsp;        @Serializable(with = InetAddressSerializer::class)
&nbsp;        val fromHost: InetAddress,  // Address of the sender
&nbsp;        val deviceName: String = &quot;Unknown Device&quot;,
&nbsp;        val name: String,   // Name of the file being received
&nbsp;        val status: Status = Status.PENDING,
&nbsp;        val size: Int,  // size of the file in byte
&nbsp;        val transferred: Int = 0,   // Bytes transferred so far
&nbsp;        val transferTime: Int = 1,  // Time taken to transfer the file in ms
&nbsp;        @Serializable(with = FileSerializer::class)
&nbsp;        val file: File? = null,
&nbsp;    )
&nbsp;
&nbsp;    // Atomic Integer is a thread-safe integer, using incrementAndGet() method to
&nbsp;    // generate unique transfer ID without worrying about race conditions
&nbsp;    private val transferIdAtomic = AtomicInteger()
&nbsp;
&nbsp;
&nbsp;    // This is a MutableStateFlow holding a list of OutgoingTransferInfo object, It used to hold
&nbsp;    // and manage a list of ongoing file transfers.
&nbsp;    private val _outgoingTransfers = MutableStateFlow(emptyList&lt;OutgoingTransferInfo&gt;())
&nbsp;    // This is the public accessible Flow, used to observe the list of ongoing file transfers
&nbsp;    val outgoingTransfers: Flow&lt;List&lt;OutgoingTransferInfo&gt;&gt; = _outgoingTransfers.asStateFlow()
&nbsp;
&nbsp;    // similar to the previous one, it holds a list of IncomingTransferInfo object.
&nbsp;    private val _incomingTransfers = MutableStateFlow(emptyList&lt;IncomingTransferInfo&gt;())
&nbsp;    val incomingTransfers: Flow&lt;List&lt;IncomingTransferInfo&gt;&gt; = _incomingTransfers.asStateFlow()
&nbsp;
&nbsp;    // This method (getListeningPort) is provided by the NanoHTTPD to get the port number which the
&nbsp;    // server is listening.
&nbsp;    val localPort: Int
&nbsp;        get() = super.getListeningPort()
&nbsp;
&nbsp;    /*
&nbsp;    Initialization Block:
&nbsp;    Fetches all qualified files and combined with previous list of files, then sorted by
&nbsp;    requestReceivedTime in descending order.
&nbsp;     */
&nbsp;    init {
&nbsp;        scope.launch {
&nbsp;            // fetch all files in receiveDir directory that end with .rx.json extension
&nbsp;            val incomingFiles = receiveDir.listFiles { _ , fileName: String? -&gt;
&nbsp;                fileName?.endsWith(&quot;.rx.json&quot;) == true
&nbsp;            }?.map {
&nbsp;                // It deserializes the JSON file into an IncomingTransferInfo object
&nbsp;                json.decodeFromString(IncomingTransferInfo.serializer(), it.readText())
&nbsp;                // if no files match the criteria, return an empty list
&nbsp;            } ?: emptyList()
&nbsp;            NotificationHelper.createNotificationChannel(appContext)
&nbsp;            /*
&nbsp;             updates the _incomingTransfers MutableStateFlow with the list of incoming files
&nbsp;             It combines the previous list with newly read files from the directory
&nbsp;             All the files are sorted by requestReceivedTime in descending order, which means
&nbsp;             the latest request will be listed first
&nbsp;             */
&nbsp;            _incomingTransfers.update { prev -&gt;
&nbsp;                buildList {
&nbsp;                    addAll(prev)
&nbsp;                    addAll(incomingFiles.sortedByDescending { it.requestReceivedTime })
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    This is a crucial function that implement an HTTP Server
&nbsp;     */
&nbsp;    override fun serve(session: IHTTPSession): Response {
&nbsp;        // Extracts the URI from the session, which is the path of the request
&nbsp;        val path = session.uri
&nbsp;        mLogger(Log.INFO, &quot;$logPrefix : ${session.method} ${session.uri}&quot;)
&nbsp;        //Create instance of the JSON Schema
&nbsp;        val JSONschema = JSONSchema()
&nbsp;
&nbsp;        if (path.startsWith(&quot;/ping&quot;)) {
&nbsp;            //Simple endpoint to check if server is responsive
&nbsp;            return newFixedLengthResponse(&quot;PONG&quot;)
&nbsp;        }
&nbsp;
&nbsp;        // check if the path is for download, indicating the request wants to download a file
&nbsp;            // 1) /myinfo route
&nbsp;        if (path.startsWith(&quot;/myinfo&quot;)) {
&nbsp;                return handleMyInfoRequest()
&nbsp;            }
&nbsp;            else if (path.startsWith(&quot;/updateUserInfo&quot;)) {
&nbsp;                // Read the POST body (assumed JSON)
&nbsp;                val postData = session.inputStream.bufferedReader().readText()
&nbsp;
&nbsp;                //Validates JSON payload
&nbsp;                if(!JSONschema.schemaValidation(postData)){
&nbsp;                    return newFixedLengthResponse(
&nbsp;                        Response.Status.BAD_REQUEST, &quot;application/json&quot;, &quot;&quot;&quot;{&quot;error&quot;:&quot;Invalid JSON schema&quot;}&quot;&quot;&quot;
&nbsp;                    )
&nbsp;                }
&nbsp;
&nbsp;                try {
&nbsp;                    // Decode the JSON payload into a UserEntity
&nbsp;                    val updatedUser = json.decodeFromString(UserEntity.serializer(), postData)
&nbsp;                    // Update or insert the user info in the database
&nbsp;                    runBlocking {
&nbsp;                        userRepository.insertOrUpdateUser(updatedUser.uuid, updatedUser.name, updatedUser.address)
&nbsp;                    }
&nbsp;                    return newFixedLengthResponse(
&nbsp;                        Response.Status.OK, &quot;application/json&quot;, &quot;&quot;&quot;{&quot;status&quot;:&quot;OK&quot;}&quot;&quot;&quot;
&nbsp;                    )
&nbsp;                } catch (e: Exception) {
&nbsp;                    e.printStackTrace()
&nbsp;                    return newFixedLengthResponse(
&nbsp;                        Response.Status.BAD_REQUEST, &quot;application/json&quot;, &quot;&quot;&quot;{&quot;error&quot;:&quot;Invalid user data&quot;}&quot;&quot;&quot;
&nbsp;                    )
&nbsp;                }
&nbsp;            }
&nbsp;        else if (path.startsWith(&quot;/updateUserInfo&quot;)) {
&nbsp;            // Read the POST body (assumed JSON)
&nbsp;            val postData = session.inputStream.bufferedReader().readText()
&nbsp;            try {
&nbsp;                // Decode the JSON payload into a UserEntity
&nbsp;                val updatedUser = json.decodeFromString(UserEntity.serializer(), postData)
&nbsp;                // Update or insert the user info in the database
&nbsp;                runBlocking {
&nbsp;                    userRepository.insertOrUpdateUser(updatedUser.uuid, updatedUser.name, updatedUser.address)
&nbsp;                }
&nbsp;                return newFixedLengthResponse(
&nbsp;                    Response.Status.OK, &quot;application/json&quot;, &quot;&quot;&quot;{&quot;status&quot;:&quot;OK&quot;}&quot;&quot;&quot;
&nbsp;                )
&nbsp;            } catch (e: Exception) {
&nbsp;                e.printStackTrace()
&nbsp;                return newFixedLengthResponse(
&nbsp;                    Response.Status.BAD_REQUEST, &quot;application/json&quot;, &quot;&quot;&quot;{&quot;error&quot;:&quot;Invalid user data&quot;}&quot;&quot;&quot;
&nbsp;                )
&nbsp;            }
&nbsp;        }
&nbsp;            // 2) /download/
&nbsp;        else if (path.startsWith(&quot;/download/&quot;)) {
&nbsp;            // Extracts the transfer ID (Integer)from the path by taking the last part of the path
&nbsp;            val xferId = path.substringAfterLast(&quot;/&quot;).toInt()
&nbsp;            // Find the outgoing transfer with the given xferId
&nbsp;            val outgoingXfer = _outgoingTransfers.value.first {
&nbsp;                it.id == xferId
&nbsp;            }
&nbsp;            // This tracks how many bytes have been read from the stream
&nbsp;            val contentIn = appContext.contentResolver.openInputStream(outgoingXfer.uri)?.let {
&nbsp;                InputStreamCounter(it.buffered())
&nbsp;            }
&nbsp;
&nbsp;            // If the input stream could not be opened, the function returns an HTTP response
&nbsp;            // with a status of INTERNAL_ERROR and an error message
&nbsp;            if(contentIn == null) {
&nbsp;                mLogger(Log.ERROR, &quot;$logPrefix Failed to open input stream to serve $path - ${outgoingXfer.uri}&quot;)
&nbsp;                return newFixedLengthResponse(
&nbsp;                    Response.Status.INTERNAL_ERROR, &quot;text/plain&quot;,
&nbsp;                    &quot;Failed to open InputStream&quot;)
&nbsp;            }
&nbsp;            mLogger(Log.INFO, &quot;$logPrefix Sending file for xfer #$xferId&quot;)
&nbsp;            // Preparing the file for download
&nbsp;            val response = newFixedLengthResponse(
&nbsp;                Response.Status.OK, &quot;application/octet-stream&quot;,
&nbsp;                contentIn,
&nbsp;                outgoingXfer.size.toLong()
&nbsp;            )
&nbsp;
&nbsp;            //Provide status updates by checking how many bytes have been read periodically
&nbsp;            /*
&nbsp;            The loop runs until the stream (contentIn) is closed. Every 500 milliseconds,
&nbsp;            the code updates the _outgoingTransfers list by checking how many bytes have been read
&nbsp;            so far (contentIn.bytesRead).
&nbsp;            (.updateItem): This is a custom extension function from List
&nbsp;             */
&nbsp;            scope.launch {
&nbsp;                while(!contentIn.closed) {
&nbsp;                    _outgoingTransfers.update{ prev -&gt;
&nbsp;                        prev.updateItem(
&nbsp;                            condition = { it.id == xferId },
&nbsp;                            function = { item -&gt;
&nbsp;                                item.copy(
&nbsp;                                    transferred = contentIn.bytesRead,
&nbsp;                                )
&nbsp;                            }
&nbsp;                        )
&nbsp;                    }
&nbsp;                    delay(500)
&nbsp;                }
&nbsp;
&nbsp;                /*
&nbsp;                After the file transfer completes, it checks if the number of bytes read equals
&nbsp;                the file size. If they match, the status is set to COMPLETED,
&nbsp;                Otherwise, it&#39;s set to FAILED.
&nbsp;                 */
&nbsp;                val status = if(contentIn.bytesRead == outgoingXfer.size) {
&nbsp;                    Status.COMPLETED
&nbsp;                }else {
&nbsp;                    Status.FAILED
&nbsp;                }
&nbsp;                mLogger(Log.INFO, &quot;$logPrefix Sending file for xfer #$xferId&quot;)
&nbsp;                /*
&nbsp;                 Updating _outgoingTransfers again to set the final transferred bytes and status
&nbsp;                 (COMPLETED or FAILED).
&nbsp;                 */
&nbsp;                _outgoingTransfers.update { prev -&gt;
&nbsp;                    prev.updateItem(
&nbsp;                        condition = { it.id == xferId },
&nbsp;                        function = { item -&gt;
&nbsp;                            item.copy(
&nbsp;                                transferred = contentIn.bytesRead,
&nbsp;                                status = status
&nbsp;                            )
&nbsp;                        }
&nbsp;                    )
&nbsp;                }
&nbsp;            }
&nbsp;            // Returns the prepared response to initiate the file download.
&nbsp;            return response
&nbsp;        }
&nbsp;        // Check if it is a sending request
&nbsp;        else if(path.startsWith(&quot;/send&quot;)) {
&nbsp;            mLogger(Log.INFO, &quot;$logPrefix Received incoming transfer request&quot;)
&nbsp;            // Parse the query parameters from the URL, converting them to a key-value map
&nbsp;            val searchParams = session.queryParameterString.split(&quot;&amp;&quot;)
&nbsp;                .map {
&nbsp;                    it.substringBefore(&quot;=&quot;) to it.substringAfter(&quot;=&quot;)
&nbsp;                }.toMap()
&nbsp;
&nbsp;            // Extract the values for &quot;id&quot;, &quot;filename&quot;, &quot;size&quot;, and &quot;from&quot; from the query parameters
&nbsp;            val id = searchParams[&quot;id&quot;]
&nbsp;            val filename = URLDecoder.decode(searchParams[&quot;filename&quot;], &quot;UTF-8&quot;)
&nbsp;            // if size is missing or invalid, then defaults to -1
&nbsp;            val size = searchParams[&quot;size&quot;]?.toInt() ?: -1
&nbsp;            val fromAddr = searchParams[&quot;from&quot;]
&nbsp;
&nbsp;
&nbsp;            // if everything is ready, create a new incomingTransferInfo object that contains all the
&nbsp;            // info extract from the query parameters
&nbsp;            if(id != null &amp;&amp; filename != null &amp;&amp; fromAddr != null) {
&nbsp;                val ipStr = fromAddr
&nbsp;                val userName = runBlocking {
&nbsp;                    val user = userRepository.getUserByIp(ipStr)
&nbsp;                    user?.name ?: &quot;Unknown Device&quot;
&nbsp;                }
&nbsp;
&nbsp;                val incomingTransfer = IncomingTransferInfo(
&nbsp;                    id = id.toInt(),
&nbsp;                    fromHost = InetAddress.getByName(fromAddr),
&nbsp;                    name = filename,
&nbsp;                    size = size,
&nbsp;                    deviceName = userName
&nbsp;                )
&nbsp;
&nbsp;                //find if theres an existing convo from sender
&nbsp;                val user = runBlocking { userRepository.getUserByIp(ipStr) }
&nbsp;
&nbsp;                var routeToChatEnabled = false
&nbsp;                var chatConversationId: String? = null
&nbsp;
&nbsp;                if (user != null ) {
&nbsp;                    val localUuid = GlobalApp.GlobalUserRepo.prefs.getString(&quot;UUID&quot;, null) ?: &quot;local-user&quot;
&nbsp;                    try {
&nbsp;                        val conversation = runBlocking {
&nbsp;                            GlobalApp.GlobalUserRepo.conversationRepository.getOrCreateConversation(
&nbsp;                                localUuid = localUuid,
&nbsp;                                remoteUser = user
&nbsp;                            )
&nbsp;                        }
&nbsp;                        routeToChatEnabled = true
&nbsp;                        chatConversationId = conversation.id
&nbsp;                    } catch (e: Exception) {
&nbsp;                        Log.e(&quot;AppServer&quot;, &quot;Failed to find conversation for file sender&quot;, e)
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                //update the _incomingTransfers list with new incoming transers
&nbsp;                //then the new list is added to the top
&nbsp;                _incomingTransfers.update { prev -&gt;
&nbsp;                    buildList {
&nbsp;                        add(incomingTransfer)
&nbsp;                        addAll(prev)
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                //show notification based on whether we have a conversation from the sender
&nbsp;                if (routeToChatEnabled &amp;&amp; chatConversationId != null) {
&nbsp;                    showFileInChatNotification(incomingTransfer, chatConversationId)
&nbsp;                } else {
&nbsp;                    // Fall back to the regular file notification
&nbsp;                    NotificationHelper.showFileReceivedNotification(appContext, filename)
&nbsp;                    mLogger(Log.INFO, &quot;$logPrefix Added request id $id for $filename from ${incomingTransfer.fromHost}&quot;)
&nbsp;                }
&nbsp;                return newFixedLengthResponse(&quot;OK&quot;)
&nbsp;            }else {
&nbsp;                mLogger(Log.INFO, &quot;$logPrefix incomin transfer request - bad request - missing params&quot;)
&nbsp;                // Return an error response if any of the required parameters are missing
&nbsp;                return newFixedLengthResponse(Response.Status.BAD_REQUEST, &quot;text/plain&quot;, &quot;Bad request&quot;)
&nbsp;            }
&nbsp;        }
&nbsp;        // Handle decline request
&nbsp;        else if(path.startsWith(&quot;/decline&quot;)){
&nbsp;            // get the transfer id from the last part of path
&nbsp;            // For example: path is &quot;/decline/123&quot;, then we get 123 and converts to int
&nbsp;            val xferId = path.substringAfterLast(&quot;/&quot;).toInt()
&nbsp;            // Update _outgoingTransfers list, setting the specific item status to DECLINED
&nbsp;            _outgoingTransfers.update { prev -&gt;
&nbsp;                prev.updateItem(
&nbsp;                    condition = { it.id == xferId },
&nbsp;                    function = {
&nbsp;                        it.copy(
&nbsp;                            status = Status.DECLINED
&nbsp;                        )
&nbsp;                    }
&nbsp;                )
&nbsp;            }
&nbsp;            // return &quot;OK&quot;, indicating the decline request has been handled
&nbsp;            return newFixedLengthResponse(&quot;OK&quot;)
&nbsp;        }
&nbsp;        else if(path.startsWith(&quot;/getDeviceName&quot;)){
&nbsp;            Log.d(&quot;AppServer&quot;, &quot;local ip address: ${localVirtualAddr.hostAddress}&quot;)
&nbsp;            val settingPref: SharedPreferences by di.instance(tag=&quot;settings&quot;)
&nbsp;            return newFixedLengthResponse(settingPref.getString(&quot;device_name&quot;, Build.MODEL) ?: Build.MODEL)
&nbsp;        }
&nbsp;        else if(path.startsWith(&quot;/chat&quot;)) {
&nbsp;            //Log.d(&quot;AppServer&quot;, &quot;Received chat message*******&quot;)
&nbsp;            //Processes JSON payload into useable data
&nbsp;            val files = mutableMapOf&lt;String, String&gt;()
&nbsp;            session.parseBody(files)
&nbsp;            val jsonPayload = files[&quot;postData&quot;]  // This is where the full body lives
&nbsp;            //Log.d(&quot;AppServer&quot;, &quot;JSON Payload******: $jsonPayload&quot;)
&nbsp;
&nbsp;            //Checks if payload is null/blank
&nbsp;            if (jsonPayload.isNullOrBlank()) {
&nbsp;                Log.e(&quot;AppServer&quot;, &quot;Empty or missing JSON payload&quot;)
&nbsp;                return newFixedLengthResponse(Response.Status.BAD_REQUEST, &quot;text/plain&quot;, &quot;Empty or missing JSON payload&quot;)
&nbsp;            }else{
&nbsp;                Log.d(&quot;AppServer&quot;, &quot;JSON payload not blank&quot;)
&nbsp;            }
&nbsp;
&nbsp;            //Validates validity of JSON payload
&nbsp;            val JSONschema = JSONSchema()
&nbsp;            Log.d(&quot;AppServer&quot;, &quot;Validating JSON payload: ${jsonPayload::class.simpleName}&quot;)
&nbsp;            if (!JSONschema.schemaValidation(jsonPayload)) {
&nbsp;                Log.e(&quot;AppServer&quot;, &quot;Invalid JSON payload&quot;)
&nbsp;                return newFixedLengthResponse(Response.Status.BAD_REQUEST, &quot;application/json&quot;, &quot;&quot;&quot;{&quot;error&quot;:&quot;Invalid JSON schema&quot;}&quot;&quot;&quot;)
&nbsp;            }else{
&nbsp;                Log.d(&quot;AppServer&quot;, &quot;Valid JSON payload&quot;)
&nbsp;            }
&nbsp;
&nbsp;            //Deserialize the JSON payload
&nbsp;            val deserialzedJSON = json.decodeFromString&lt;Message&gt;(jsonPayload)
&nbsp;
&nbsp;            val chatMessage = deserialzedJSON.content ?: null
&nbsp;            val time = deserialzedJSON.dateReceived ?: System.currentTimeMillis()
&nbsp;            val senderIpStr = deserialzedJSON.sender ?: null
&nbsp;
&nbsp;            Log.d(&quot;AppServer&quot;, &quot;Received chat message: &#39;$chatMessage&#39; from $senderIpStr at $time&quot;)
&nbsp;//            val chatMessage = session.parameters[&quot;chatMessage&quot;]?.firstOrNull()
&nbsp;//            val timeParam = session.parameters[&quot;time&quot;]?.firstOrNull()
&nbsp;//            val time = timeParam?.toLongOrNull() ?: System.currentTimeMillis()
&nbsp;//            val senderIpStr = session.parameters[&quot;senderIp&quot;]?.firstOrNull()
&nbsp;
&nbsp;            if (senderIpStr == null) {
&nbsp;                return newFixedLengthResponse(Response.Status.BAD_REQUEST, &quot;text/plain&quot;, &quot;Missing senderIp parameter&quot;)
&nbsp;            }
&nbsp;
&nbsp;            val senderIp = try {
&nbsp;                InetAddress.getByName(senderIpStr)
&nbsp;            } catch (e: Exception) {
&nbsp;                Log.e(&quot;AppServer&quot;, &quot;Invalid sender IP address: $senderIpStr&quot;, e)
&nbsp;                return newFixedLengthResponse(Response.Status.BAD_REQUEST, &quot;text/plain&quot;, &quot;Invalid sender IP&quot;)
&nbsp;            }
&nbsp;
&nbsp;            // Handle optional file parameter
&nbsp;            //val fileUriStr = session.parameters[&quot;incomingfile&quot;]?.firstOrNull()
&nbsp;            val fileUriStr = deserialzedJSON.file?.toString()
&nbsp;            val incomingfile = if (fileUriStr != null) {
&nbsp;                try {
&nbsp;                    URI.create(fileUriStr)
&nbsp;                } catch (e: Exception) {
&nbsp;                    Log.e(&quot;AppServer&quot;, &quot;Invalid file URI: $fileUriStr&quot;, e)
&nbsp;                    null
&nbsp;                }
&nbsp;            } else {
&nbsp;                null
&nbsp;            }
&nbsp;
&nbsp;            Log.d(&quot;AppServer&quot;, &quot;Received chat message: &#39;$chatMessage&#39; from $senderIpStr&quot;)
&nbsp;
&nbsp;            try {
&nbsp;                val message = MessageNetworkHandler.handleIncomingMessage(
&nbsp;                    chatMessage,
&nbsp;                    time,
&nbsp;                    senderIp,
&nbsp;                    incomingfile
&nbsp;                )
&nbsp;
&nbsp;                scope.launch {
&nbsp;                    db.messageDao().addMessage(message)
&nbsp;                    Log.d(&quot;AppServer&quot;, &quot;Message saved to database: $message&quot;)
&nbsp;                }
&nbsp;
&nbsp;                // Change response type to ensure it&#39;s properly formatted
&nbsp;                return newFixedLengthResponse(Response.Status.OK, &quot;text/plain&quot;, &quot;OK&quot;)
&nbsp;            } catch (e: Exception) {
&nbsp;                Log.e(&quot;AppServer&quot;, &quot;Error processing chat message&quot;, e)
&nbsp;                return newFixedLengthResponse(Response.Status.INTERNAL_ERROR, &quot;text/plain&quot;, &quot;Error processing message&quot;)
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;        else {
&nbsp;            mLogger(Log.INFO, &quot;$logPrefix : $path - NOT FOUND&quot;)
&nbsp;            // Returns a NOT_FOUND response indicating that the requested path could not be found.
&nbsp;            return newFixedLengthResponse(
&nbsp;                Response.Status.NOT_FOUND, &quot;text/plain&quot;, &quot;not found: $path&quot;
&nbsp;            )
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    suspend fun sendDeviceName(wifiAddress: InetAddress, port: Int = DEFAULT_PORT){
&nbsp;        scope.launch {
&nbsp;            try {
&nbsp;                val ipStr = wifiAddress.hostAddress
&nbsp;                Log.d(&quot;AppServer&quot;, &quot;wifiAddress: $ipStr&quot;)
&nbsp;
&nbsp;                // GET /getDeviceName
&nbsp;                val uri = &quot;http://$ipStr:$port/getDeviceName&quot;
&nbsp;                val request = Request.Builder().url(uri).build()
&nbsp;                Log.d(&quot;AppServer&quot;, &quot;Request: $request&quot;)
&nbsp;                val response = httpClient.newCall(request).execute()
&nbsp;                Log.d(&quot;AppServer&quot;, &quot;Response: $response&quot;)
&nbsp;
&nbsp;                // The remote device&#39;s name
&nbsp;                val remoteDeviceName = response.body?.string()
&nbsp;                Log.d(&quot;AppServer&quot;, &quot;Remote device name: $remoteDeviceName&quot;)
&nbsp;
&nbsp;                response.close() // best practice: close the response
&nbsp;
&nbsp;                if (!remoteDeviceName.isNullOrEmpty()) {
&nbsp;                    runBlocking {
&nbsp;                        val existingUser = userRepository.getUserByIp(ipStr)
&nbsp;                        if (existingUser == null) {
&nbsp;                            // No user? Insert with a temporary or random UUID
&nbsp;                            val pseudoUuid = &quot;temp-$ipStr&quot;
&nbsp;                            userRepository.insertOrUpdateUser(
&nbsp;                                uuid = pseudoUuid,
&nbsp;                                name = remoteDeviceName,
&nbsp;                                address = ipStr
&nbsp;                            )
&nbsp;                        } else {
&nbsp;                            // Already have a user? Update the name
&nbsp;                            userRepository.insertOrUpdateUser(
&nbsp;                                uuid = existingUser.uuid,
&nbsp;                                name = remoteDeviceName,
&nbsp;                                address = existingUser.address
&nbsp;                            )
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;            } catch (e: Exception) {
&nbsp;                e.printStackTrace()
&nbsp;                Log.e(&quot;AppServer&quot;, &quot;Failed to get device name from ${wifiAddress.hostAddress}&quot;)
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;    /*fun requestRemoteUserInfo(remoteAddr: InetAddress, port: Int = DEFAULT_PORT) {//old
&nbsp;        scope.launch {
&nbsp;            try {
&nbsp;                val url = &quot;http://${remoteAddr.hostAddress}:$port/myinfo&quot;
&nbsp;                val request = Request.Builder().url(url).build()
&nbsp;                val response = httpClient.newCall(request).execute()
&nbsp;                val userJson = response.body?.string()
&nbsp;                response.close()
&nbsp;
&nbsp;                if (!userJson.isNullOrEmpty()) {
&nbsp;                    // Decode JSON into a UserEntity
&nbsp;                    val remoteUser = json.decodeFromString(UserEntity.serializer(), userJson)
&nbsp;                    // Insert or update in DB
&nbsp;                    userRepository.insertOrUpdateUser(remoteUser.uuid, remoteUser.name)
&nbsp;                    // Possibly store lastSeen, remote IP, etc., if your entity includes those fields
&nbsp;                }
&nbsp;            } catch (e: Exception) {
&nbsp;                Log.e(&quot;AppServer&quot;, &quot;Failed to fetch /myinfo from $remoteAddr&quot;, e)
&nbsp;            }
&nbsp;        }
&nbsp;    }*/
&nbsp;
&nbsp;    /**
&nbsp;     * Add an outgoing transfer. This is done using a Uri so that we don&#39;t have to make our own
&nbsp;     * copy of the file the user wants to transfer.
&nbsp;     */
&nbsp;
&nbsp;    // Add a new function to show notifications that route to the chat screen
&nbsp;    private fun showFileInChatNotification(transfer: IncomingTransferInfo, conversationId: String) {
&nbsp;        try {
&nbsp;            val title = &quot;File Received&quot;
&nbsp;            val content = &quot;Tap to view ${transfer.name} in chat&quot;
&nbsp;
&nbsp;            val intent = Intent(appContext, MainActivity::class.java).apply {
&nbsp;                action = &quot;OPEN_CHAT_CONVERSATION&quot;
&nbsp;                putExtra(&quot;conversationId&quot;, conversationId)
&nbsp;                putExtra(&quot;from_notification&quot;, true)
&nbsp;                flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP
&nbsp;            }
&nbsp;
&nbsp;            val pendingIntent = PendingIntent.getActivity(
&nbsp;                appContext, 1005, intent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
&nbsp;            )
&nbsp;
&nbsp;            val channelId = &quot;file_receive_channel&quot;
&nbsp;
&nbsp;            val notification = NotificationCompat.Builder(appContext, channelId)
&nbsp;                .setSmallIcon(R.drawable.ic_launcher_foreground)
&nbsp;                .setContentTitle(title)
&nbsp;                .setContentText(content)
&nbsp;                .setPriority(NotificationCompat.PRIORITY_HIGH)
&nbsp;                .setDefaults(NotificationCompat.DEFAULT_VIBRATE or NotificationCompat.DEFAULT_SOUND)
&nbsp;                .setContentIntent(pendingIntent)
&nbsp;                .setAutoCancel(true)
&nbsp;                .build()
&nbsp;
&nbsp;            val notificationManager = appContext.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
&nbsp;            notificationManager.notify(1005, notification)
&nbsp;
&nbsp;            Log.d(&quot;AppServer&quot;, &quot;Showed notification for file in chat&quot;)
&nbsp;        } catch (e: Exception) {
&nbsp;            Log.e(&quot;AppServer&quot;, &quot;Failed to show file in chat notification&quot;, e)
&nbsp;            // Fall back to regular notification
&nbsp;            NotificationHelper.showFileReceivedNotification(appContext, transfer.name)
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    fun addOutgoingTransfer(//change to json
&nbsp;        uri: Uri,   // The uri of the file to be transferred
&nbsp;        toNode: InetAddress,    // The recipient&#39;s IP address
&nbsp;        toPort: Int = DEFAULT_PORT, // The recipient&#39;s port number
&nbsp;    ): OutgoingTransferInfo {
&nbsp;        // generate a unique transfer ID
&nbsp;        val transferId = transferIdAtomic.incrementAndGet()
&nbsp;        // Get the name and size of the file or content using
&nbsp;        // customized extension function of ContentResolver
&nbsp;        val nameAndSize = appContext.contentResolver.getUriNameAndSize(uri)
&nbsp;        val validName = nameAndSize.name ?: &quot;unknown&quot;
&nbsp;        mLogger(Log.INFO, &quot;$logPrefix adding outgoing transfer of $uri &quot; +
&nbsp;                &quot;(name=${nameAndSize.name} size=${nameAndSize.size} to $toNode:$toPort&quot;)
&nbsp;
&nbsp;        // create an OutgoingTransferInfo object with all transfer information
&nbsp;        val outgoingTransfer = OutgoingTransferInfo(
&nbsp;            id = transferId,
&nbsp;            name = validName,
&nbsp;            uri = uri ,
&nbsp;            toHost = toNode,
&nbsp;            size = nameAndSize.size.toInt(),
&nbsp;        )
&nbsp;
&nbsp;        scope.launch(Dispatchers.IO){
&nbsp;            try{
&nbsp;
&nbsp;                val gs = Gson()
&nbsp;                val json = gs.toJson(outgoingTransfer)
&nbsp;
&nbsp;                val bodtype = &quot;application/json; charset=utf-8&quot;.toMediaTypeOrNull()
&nbsp;                val bod = json.toRequestBody(bodtype)
&nbsp;                val request = Request.Builder().url(&quot;http://${toNode.hostAddress}:$toPort/&quot; +
&nbsp;                        &quot;send?id=$transferId&amp;filename=${URLEncoder.encode(validName, &quot;UTF-8&quot;)}&quot; +
&nbsp;                        &quot;&amp;size=${nameAndSize.size}&amp;from=${localVirtualAddr.hostAddress}&quot;)
&nbsp;                    .post(bod)
&nbsp;                    .build()//changed this to send a post request
&nbsp;
&nbsp;                mLogger(Log.INFO, &quot;$logPrefix notifying $toNode of incoming transfer&quot;)
&nbsp;
&nbsp;                val resp = httpClient.newCall(request).execute()
&nbsp;                val serverResponse = resp.body?.string()
&nbsp;                mLogger(Log.INFO, &quot;$logPrefix - received response: $serverResponse&quot;)
&nbsp;
&nbsp;            } catch(e: Exception){
&nbsp;                mLogger(Log.ERROR, &quot;$logPrefix - exception: $e&quot;)
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        _outgoingTransfers.update { prev -&gt;
&nbsp;            buildList {
&nbsp;                add(outgoingTransfer)
&nbsp;                addAll(prev)
&nbsp;            }
&nbsp;        }
&nbsp;        return outgoingTransfer
&nbsp;    }
&nbsp;
&nbsp;    fun removeOutgoingTransfer(transferId: Int) {
&nbsp;        _outgoingTransfers.update { prev -&gt;
&nbsp;            prev.filter { it.id != transferId }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;     Accept an incoming transfer
&nbsp;     */
&nbsp;    fun acceptIncomingTransfer(
&nbsp;        transfer: IncomingTransferInfo,
&nbsp;        destFile: File,
&nbsp;        fromPort: Int = DEFAULT_PORT,
&nbsp;    ) {
&nbsp;        // record the current time
&nbsp;        val startTime = System.currentTimeMillis()
&nbsp;        // Update the _incomingTransfers list, setting the status to IN_PROGRESS
&nbsp;        _incomingTransfers.update { prev -&gt;
&nbsp;            prev.updateItem(
&nbsp;                condition = { it.id == transfer.id },
&nbsp;                function = { item -&gt; item.copy(
&nbsp;                    status = Status.IN_PROGRESS,
&nbsp;                )
&nbsp;                }
&nbsp;            )
&nbsp;        }
&nbsp;        try {
&nbsp;            // Build the request to download the file from the sender
&nbsp;            val request = Request.Builder()
&nbsp;                .url(&quot;http://${transfer.fromHost.hostAddress}:$fromPort/download/${transfer.id}&quot;)
&nbsp;                .build()
&nbsp;            // sending the request using OkHttp3
&nbsp;            val response = httpClient.newCall(request).execute()
&nbsp;            // Get the size of the file that will be downloaded from response
&nbsp;            val fileSize = response.headersContentLength()
&nbsp;            // 0L -&gt; L indicates type Long
&nbsp;            var lastUpdateTime = 0L
&nbsp;            /*
&nbsp;            Download file,Writes it to destFile, and reports progress every 500 ms
&nbsp;             */
&nbsp;            val totalTransferred = response.body?.byteStream()?.use { responseIn -&gt;
&nbsp;                FileOutputStream(destFile).use { fileOut -&gt;
&nbsp;                    responseIn.copyToWithProgressCallback(
&nbsp;                        out = fileOut,
&nbsp;                        onProgress = { bytesTransferred -&gt;
&nbsp;                            val timeNow = System.currentTimeMillis()
&nbsp;                            if(timeNow - lastUpdateTime &gt; 500) {
&nbsp;                                _incomingTransfers.update { prev -&gt;
&nbsp;                                    prev.updateItem(
&nbsp;                                        condition = { it.id == transfer.id },
&nbsp;                                        function = { item -&gt;
&nbsp;                                            item.copy(
&nbsp;                                                transferred = bytesTransferred.toInt()
&nbsp;                                            )
&nbsp;                                        }
&nbsp;                                    )
&nbsp;                                }
&nbsp;                                lastUpdateTime = System.currentTimeMillis()
&nbsp;                            }
&nbsp;                        }
&nbsp;                    )
&nbsp;                }
&nbsp;            }
&nbsp;            response.close()
&nbsp;            // calculate the total time taken for downloading the file
&nbsp;            val transferDurationMs = (System.currentTimeMillis() - startTime).toInt()
&nbsp;            // Update the status of the transfer based on whether the entire file was
&nbsp;            // successfully downloaded or not
&nbsp;            val incomingTransfersVal = _incomingTransfers.updateAndGet { prev -&gt;
&nbsp;                prev.updateItem(
&nbsp;                    condition = { it.id == transfer.id },
&nbsp;                    function = { item -&gt;
&nbsp;                        item.copy(
&nbsp;                            transferTime = transferDurationMs,
&nbsp;                            status = if(totalTransferred == fileSize) {
&nbsp;                                Status.COMPLETED
&nbsp;                            }else {
&nbsp;                                Status.FAILED
&nbsp;                            },
&nbsp;                            file = destFile,
&nbsp;                            transferred = totalTransferred?.toInt() ?: item.transferred
&nbsp;                        )
&nbsp;                    }
&nbsp;                )
&nbsp;            }
&nbsp;
&nbsp;            //Write JSON to file so received files can be listed after app restarts etc.
&nbsp;            val incomingTransfer = incomingTransfersVal.firstOrNull {
&nbsp;                it.id == transfer.id
&nbsp;            }
&nbsp;            // Create a JSON file and write the serialized transfer info to the file
&nbsp;            if(incomingTransfer != null) {
&nbsp;                val jsonFile = File(receiveDir, &quot;${incomingTransfer.name}.rx.json&quot;)
&nbsp;                jsonFile.writeText(json.encodeToString(IncomingTransferInfo.serializer(), incomingTransfer))
&nbsp;            }
&nbsp;            val speedKBS = transfer.size / transferDurationMs
&nbsp;            mLogger(Log.INFO, &quot;$logPrefix acceptIncomingTransfer successful: Downloaded &quot; +
&nbsp;                    &quot;${transfer.size}bytes in ${transfer.transferTime}ms ($speedKBS) KB/s&quot;)
&nbsp;        }
&nbsp;        catch(e: Exception) {
&nbsp;            mLogger(Log.ERROR, &quot;$logPrefix acceptIncomingTransfer ($transfer) FAILED&quot;, e)
&nbsp;            _incomingTransfers.update { prev -&gt;
&nbsp;                prev.updateItem(
&nbsp;                    condition = { it.id == transfer.id },
&nbsp;                    function = { item -&gt; item.copy(
&nbsp;                        transferred = destFile.length().toInt(),
&nbsp;                        status = Status.FAILED,
&nbsp;                    )
&nbsp;                    }
&nbsp;                )
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if a device is reachable at the application level
&nbsp;     * This performs a lightweight check without doing a full user info exchange
&nbsp;     */
&nbsp;    fun checkDeviceReachable(remoteAddr: InetAddress, port: Int = DEFAULT_PORT): Boolean {
&nbsp;        try {
&nbsp;            val url = &quot;http://${remoteAddr.hostAddress}:$port/ping&quot;
&nbsp;            val request = Request.Builder().url(url).build()
&nbsp;
&nbsp;            httpClient.newCall(request).execute().use { response -&gt;
&nbsp;                return response.isSuccessful
&nbsp;            }
&nbsp;        } catch (e: Exception) {
&nbsp;            Log.e(&quot;AppServer&quot;, &quot;Failed to check if device ${remoteAddr.hostAddress} is reachable&quot;, e)
&nbsp;            return false
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    Decline an incoming transfer
&nbsp;    It sends an HTTP request to notify the sender that the file transfer has been
&nbsp;    declined and updates the status of the transfer to DECLINED in the local list
&nbsp;    of incoming transfers.
&nbsp;     */
&nbsp;    suspend fun onDeclineIncomingTransfer(
&nbsp;        transfer: IncomingTransferInfo,
&nbsp;        fromPort: Int = DEFAULT_PORT,
&nbsp;    ) {
&nbsp;        /*
&nbsp;         This block ensures that the network request is performed on the IO thread pool,
&nbsp;         which is optimized for input/output operations like networking and file handling.
&nbsp;         */
&nbsp;        withContext(Dispatchers.IO) {
&nbsp;            // Construct an HTTP request to decline the incoming transfer(Using OkHTTP3)
&nbsp;            val request = Request.Builder()
&nbsp;                .url(&quot;http://${transfer.fromHost.hostAddress}:$fromPort/decline/${transfer.id}&quot;)
&nbsp;                .build()
&nbsp;            try {
&nbsp;                // Send the request to the sender and get the response
&nbsp;                val response = httpClient.newCall(request).execute()
&nbsp;                val strResponse = response.body?.string()
&nbsp;                mLogger(Log.DEBUG, &quot;$logPrefix - onDeclineIncomingTransfer - request to: ${request.url} : response = $strResponse&quot;)
&nbsp;            }catch(e: Exception) {
&nbsp;                mLogger(Log.WARN, &quot;$logPrefix - onDeclineIncomingTransfer : exception- request to: ${request.url} : FAIL&quot;, e)
&nbsp;            }
&nbsp;        }
&nbsp;        // update the _incomingTransfers list, setting the status to DECLINED
&nbsp;        _incomingTransfers.update { prev -&gt;
&nbsp;            prev.updateItem(
&nbsp;                condition = { it.id == transfer.id },
&nbsp;                function = {
&nbsp;                    it.copy(
&nbsp;                        status = Status.DECLINED,
&nbsp;                    )
&nbsp;                }
&nbsp;            )
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;    Delete an incoming transfer
&nbsp;    It removes both file associated with the transfer and the metadata (stored in a JSON file)
&nbsp;    from the device, then updates the internal state to remove the transfer from the list of
&nbsp;    incoming transfers.
&nbsp;     */
&nbsp;    suspend fun onDeleteIncomingTransfer(
&nbsp;        incomingTransfer: IncomingTransferInfo
&nbsp;    ) {
&nbsp;        /*
&nbsp;        Since file operations can be slow and block the main thread,
&nbsp;        it is important to run them on the IO thread pool,
&nbsp;        which is optimized for disk and network I/O tasks.
&nbsp;         */
&nbsp;        withContext(Dispatchers.IO) {
&nbsp;            // It will create a File object pointing to the .rx.json file
&nbsp;            // that stores metadata about the transfer.
&nbsp;            val jsonFile = incomingTransfer.file?.let {
&nbsp;                File(it.parentFile, it.name + &quot;.rx.json&quot;)
&nbsp;            }
&nbsp;            // Delete both the file and the JSON file associated with the transfer
&nbsp;            incomingTransfer.file?.delete()
&nbsp;            jsonFile?.delete()
&nbsp;            // Update the _incomingTransfers list, removing the transfer that was just deleted
&nbsp;            _incomingTransfers.update { prev -&gt;
&nbsp;                prev.filter { it.id != incomingTransfer.id }
&nbsp;            }
&nbsp;
&nbsp;            // Ensure Jetpack Compose recomposes UI before handling another delete
&nbsp;            withContext(Dispatchers.Main) {
&nbsp;                delay(150)
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Send a chat message and return delivery status
&nbsp;     */
&nbsp;    suspend fun sendChatMessageWithStatus(address: InetAddress, time: Long, message: String, f: URI?): Boolean {
&nbsp;
&nbsp;        try {
&nbsp;            if (TestDeviceService.isTestDevice(address)) {
&nbsp;                // Create an echo response from our test device
&nbsp;                val testMessage = Message(
&nbsp;                    id = 0,
&nbsp;                    dateReceived = System.currentTimeMillis(),
&nbsp;                    content = &quot;Echo: $message&quot;,
&nbsp;                    sender = TestDeviceService.TEST_DEVICE_NAME,
&nbsp;                    chat = TestDeviceService.TEST_DEVICE_NAME,
&nbsp;                    file = f //dont send file with echo messages
&nbsp;                )
&nbsp;
&nbsp;                // Store the echo response in our database
&nbsp;                db.messageDao().addMessage(testMessage)
&nbsp;                Log.d(&quot;AppServer&quot;, &quot;Test device echoed message: $message&quot;)
&nbsp;                return true
&nbsp;            }
&nbsp;
&nbsp;            // Original code for real devices
&nbsp;            val httpUrl = HttpUrl.Builder()
&nbsp;                .scheme(&quot;http&quot;)
&nbsp;                .host(address.hostAddress)
&nbsp;                .port(DEFAULT_PORT)
&nbsp;                .addPathSegment(&quot;chat&quot;)
&nbsp;                .addQueryParameter(&quot;chatMessage&quot;, message)
&nbsp;                .addQueryParameter(&quot;time&quot;, time.toString())
&nbsp;                .addQueryParameter(&quot;senderIp&quot;, localVirtualAddr.hostAddress)
&nbsp;                .build()
&nbsp;
&nbsp;            Log.d(&quot;AppServer&quot;, &quot;Request URL: $httpUrl&quot;)
&nbsp;
&nbsp;            val gs = Gson()
&nbsp;            val msg = Message(//test this
&nbsp;                id = 0,
&nbsp;                dateReceived = time,
&nbsp;                sender = localVirtualAddr.hostName,
&nbsp;                chat = address.hostAddress,
&nbsp;                content = message,
&nbsp;                file = null//made the file null so that the file doesn&#39;t send
&nbsp;            )
&nbsp;            Log.d(&quot;AppServer&quot;, &quot;Messagefile: ${msg.file.toString()}&quot;)
&nbsp;            val msgJson = gs.toJson(msg)
&nbsp;            //modified http
&nbsp;            val httpURL = HttpUrl.Builder() .scheme(&quot;http&quot;) .host(address.hostAddress) .port(DEFAULT_PORT) .addPathSegment(&quot;chat&quot;).build()
&nbsp;            //Log.d(&quot;AppServer&quot;, &quot;HTTP URL: $httpURL&quot;)
&nbsp;            //post request body
&nbsp;            val mt = &quot;application/json; charset=utf-8&quot;.toMediaType()
&nbsp;            val rbody = msgJson.toRequestBody(mt)
&nbsp;            //Log.d(&quot;Appserver&quot;, &quot;HTTP URL: $httpUrl&quot;)
&nbsp;
&nbsp;            val request = Request.Builder()
&nbsp;                .url(httpUrl)
&nbsp;                .post(rbody)
&nbsp;                .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)
&nbsp;                .build()
&nbsp;
&nbsp;            // Execute the request with proper error handling
&nbsp;            try {
&nbsp;                httpClient.newCall(request).execute().use { response -&gt;
&nbsp;                    val successful = response.isSuccessful
&nbsp;                    if (successful) {
&nbsp;                        Log.d(&quot;AppServer&quot;, &quot;Message successfully sent to ${address.hostAddress}&quot;)
&nbsp;                    } else {
&nbsp;                        Log.d(&quot;AppServer&quot;, &quot;Failed to send message to ${address.hostAddress}, status code: ${response.code}&quot;)
&nbsp;                    }
&nbsp;                    return successful
&nbsp;                }
&nbsp;            } catch (e: Exception) {
&nbsp;                Log.e(&quot;AppServer&quot;, &quot;Failed to send message to ${address.hostAddress}: ${e.message}&quot;, e)
&nbsp;                return false
&nbsp;            }
&nbsp;
&nbsp;        } catch (e: Exception) {
&nbsp;            e.printStackTrace()
&nbsp;            Log.d(&quot;AppServer&quot;, &quot;Failed to send message to ${address.hostAddress}: ${e.message}&quot;)
&nbsp;            return false
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /*
&nbsp;
&nbsp;    fun sendChatMessage(address: InetAddress, time: Long, message: String, f: URI?) {//need to test this
&nbsp;        scope.launch {//check to see if this accommodates for json
&nbsp;            //not sending URI, i don&#39;t think the json is working
&nbsp;            try {
&nbsp;                Log.d(&quot;AppServer&quot;, &quot;chat message: $message&quot;)
&nbsp;                if (TestDeviceService.isTestDevice(address)) {
&nbsp;                    // Create an echo response from our test device
&nbsp;                    val testMessage = Message(
&nbsp;                        id = 0,
&nbsp;                        dateReceived = System.currentTimeMillis(),
&nbsp;                        content = &quot;Echo: $message&quot;,
&nbsp;                        sender = TestDeviceService.TEST_DEVICE_NAME,
&nbsp;                        chat = TestDeviceService.TEST_DEVICE_NAME,
&nbsp;                        file = f//ok this is working
&nbsp;                    )
&nbsp;
&nbsp;                    // Store the echo response in our database
&nbsp;                    db.messageDao().addMessage(testMessage)
&nbsp;                    Log.d(&quot;AppServer&quot;, &quot;Test device echoed message: $message&quot;)
&nbsp;                    return@launch
&nbsp;                }
&nbsp;
&nbsp;                //original code for real devices
&nbsp;                val httpUrl = HttpUrl.Builder()
&nbsp;                    .scheme(&quot;http&quot;)
&nbsp;                    .host(address.hostAddress)
&nbsp;                    .port(DEFAULT_PORT)
&nbsp;                    .addPathSegment(&quot;chat&quot;)
&nbsp;                    .addQueryParameter(&quot;chatMessage&quot;, message)
&nbsp;                    .addQueryParameter(&quot;time&quot;, time.toString())
&nbsp;                    .addQueryParameter(&quot;senderIp&quot;, localVirtualAddr.hostAddress)
&nbsp;                    .build()
&nbsp;
&nbsp;                Log.d(&quot;AppServer&quot;, &quot;Request URL: $httpUrl&quot;)
&nbsp;
&nbsp;                val request = Request.Builder()
&nbsp;                    .url(httpUrl)
&nbsp;                    .build()
&nbsp;
&nbsp;                val response = httpClient.newCall(request).execute()
&nbsp;                Log.d(&quot;AppServer&quot;, &quot;Response: ${response.code}&quot;)
&nbsp;
&nbsp;            }
&nbsp;            catch (e: Exception) {
&nbsp;                e.printStackTrace()
&nbsp;                Log.d(&quot;AppServer&quot;, &quot;Failed to send message to ${address.hostAddress}&quot;)
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;     */
&nbsp;    fun pushUserInfoTo(remoteAddr: InetAddress, port: Int = DEFAULT_PORT) {
&nbsp;        scope.launch {
&nbsp;            // Retrieve your local user info (assume you store your UUID in SharedPreferences)
&nbsp;            val sharedPrefs: SharedPreferences by di.instance(tag = &quot;settings&quot;)
&nbsp;            val localUuid = sharedPrefs.getString(&quot;UUID&quot;, null)
&nbsp;            if (localUuid == null) {
&nbsp;                Log.e(&quot;AppServer&quot;, &quot;Local UUID not found, cannot push user info&quot;)
&nbsp;                return@launch
&nbsp;            }
&nbsp;            val localUser = runBlocking { userRepository.getUser(localUuid) }
&nbsp;            if (localUser == null) {
&nbsp;                Log.e(&quot;AppServer&quot;, &quot;Local user info not found in DB, cannot push user info&quot;)
&nbsp;                return@launch
&nbsp;            }
&nbsp;
&nbsp;            // Convert the user info to JSON
&nbsp;            val userJson = json.encodeToString(UserEntity.serializer(), localUser)
&nbsp;            val url = &quot;http://${remoteAddr.hostAddress}:$port/updateUserInfo&quot;
&nbsp;            val requestBody = userJson.toRequestBody(&quot;application/json&quot;.toMediaType())
&nbsp;            val request = Request.Builder()
&nbsp;                .url(url)
&nbsp;                .post(requestBody)
&nbsp;                .build()
&nbsp;
&nbsp;            Log.d(&quot;AppServer&quot;, &quot;Pushing user info to $url with payload: $userJson&quot;)
&nbsp;
&nbsp;            try {
&nbsp;                val response = httpClient.newCall(request).execute()
&nbsp;                // Log the response code and body (if any)
&nbsp;                val responseBody = response.body?.string()
&nbsp;                Log.d(&quot;AppServer&quot;, &quot;Response from ${remoteAddr.hostAddress}: Code=${response.code}, Body=$responseBody&quot;)
&nbsp;            } catch (e: Exception) {
&nbsp;                Log.e(&quot;AppServer&quot;, &quot;Failed to push user info to ${remoteAddr.hostAddress}&quot;, e)
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;    fun requestRemoteUserInfo(remoteAddr: InetAddress, port: Int = DEFAULT_PORT) {
&nbsp;        //Special handling for test devices
&nbsp;        val ipAddress = remoteAddr.hostAddress
&nbsp;
&nbsp;        // Online test device should always be &quot;online&quot;
&nbsp;        if (ipAddress == TestDeviceService.TEST_DEVICE_IP) {
&nbsp;            DeviceStatusManager.updateDeviceStatus(ipAddress, true)
&nbsp;            return
&nbsp;        }
&nbsp;
&nbsp;        // Offline test device should always be &quot;offline&quot;
&nbsp;        if (ipAddress == TestDeviceService.TEST_DEVICE_IP_OFFLINE) {
&nbsp;            DeviceStatusManager.updateDeviceStatus(ipAddress, false)
&nbsp;            return
&nbsp;        }
&nbsp;        scope.launch {
&nbsp;            try {
&nbsp;                val url = &quot;http://${remoteAddr.hostAddress}:$port/myinfo&quot;
&nbsp;                val request = Request.Builder().url(url).build()
&nbsp;                Log.d(&quot;AppServer&quot;, &quot;Requesting remote user info from $url&quot;)
&nbsp;
&nbsp;                val response = httpClient.newCall(request).execute()
&nbsp;                val userJson = response.body?.string()
&nbsp;                Log.d(&quot;AppServer&quot;, &quot;Received user info from ${remoteAddr.hostAddress}: $userJson&quot;)
&nbsp;                response.close()
&nbsp;
&nbsp;                if (!userJson.isNullOrEmpty()) {
&nbsp;                    // 1) Decode JSON
&nbsp;                    val remoteUser = json.decodeFromString(UserEntity.serializer(), userJson)
&nbsp;
&nbsp;                    // 2) Optionally override with the *actual* IP of the request
&nbsp;                    //    if you prefer forcing the discovered IP over the users self-reported IP.
&nbsp;                    val remoteUserWithIp = remoteUser.copy(
&nbsp;                        address = remoteAddr.hostAddress
&nbsp;                    )
&nbsp;
&nbsp;                    // 3) Insert or update that IP in the DB
&nbsp;                    userRepository.insertOrUpdateUser(
&nbsp;                        remoteUserWithIp.uuid,
&nbsp;                        remoteUserWithIp.name,
&nbsp;                        remoteUserWithIp.address
&nbsp;                    )
&nbsp;
&nbsp;                    // 4) update user connection status to online
&nbsp;                    updateUserOnlineStatus(
&nbsp;                        userUuid = remoteUserWithIp.uuid,
&nbsp;                        isOnline = true,
&nbsp;                        userAddress = remoteUserWithIp.address
&nbsp;                    )
&nbsp;
&nbsp;                    // 5) update device status manager to show device online
&nbsp;                    DeviceStatusManager.updateDeviceStatus(remoteAddr.hostAddress, true)
&nbsp;
&nbsp;                    //try to create a conversation
&nbsp;                    try {
&nbsp;                        //get local UUID
&nbsp;                        val sharedPrefs: SharedPreferences by di.instance(tag = &quot;settings&quot;)
&nbsp;                        val localUuid = sharedPrefs.getString(&quot;UUID&quot;, null)
&nbsp;                        if ( localUuid != null){
&nbsp;                            //create convo
&nbsp;                            GlobalApp.GlobalUserRepo.conversationRepository.getOrCreateConversation(
&nbsp;                                localUuid = localUuid,
&nbsp;                                remoteUser = remoteUserWithIp
&nbsp;                            )
&nbsp;                            Log.d(&quot;AppServer&quot;, &quot;Created conversation with ${remoteUserWithIp.name}&quot;)
&nbsp;                        }
&nbsp;                    }catch (e: Exception) {
&nbsp;                        Log.e(&quot;AppServer&quot;, &quot;Failed to create conversation&quot;, e)
&nbsp;
&nbsp;                        //Update Device Status Manager to show device is offline when connection fails
&nbsp;                        DeviceStatusManager.updateDeviceStatus(remoteAddr.hostAddress, false)
&nbsp;
&nbsp;                        //update convo status for this user
&nbsp;                        val user = runBlocking { userRepository.getUserByIp(remoteAddr.hostAddress) }
&nbsp;                        if (user != null) {
&nbsp;                            updateUserOnlineStatus(
&nbsp;                                userUuid = user.uuid,
&nbsp;                                isOnline = false,
&nbsp;                                userAddress = null
&nbsp;                            )
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    Log.d(&quot;AppServer&quot;, &quot;Updated local DB with remote user info: $remoteUserWithIp&quot;)
&nbsp;                }
&nbsp;            } catch (e: Exception) {
&nbsp;                Log.e(&quot;AppServer&quot;, &quot;Failed to fetch /myinfo from ${remoteAddr.hostAddress}&quot;, e)
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    fun updateUserConnectionStatus(userUuid: String, isOnline: Boolean, userAddress: String?) {
&nbsp;        scope.launch {
&nbsp;            try {
&nbsp;                GlobalApp.GlobalUserRepo.conversationRepository.updateUserStatus(
&nbsp;                    userUuid = userUuid,
&nbsp;                    isOnline = isOnline,
&nbsp;                    userAddress = userAddress
&nbsp;                )
&nbsp;                Log.d(&quot;AppServer&quot;, &quot;Updated user $userUuid connection status: online=$isOnline, address=$userAddress&quot;)
&nbsp;            }catch (e: Exception){
&nbsp;                Log.e(&quot;AppServer&quot;, &quot;Failed to update user connection status&quot;, e)
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    fun updateUserOnlineStatus(userUuid: String, isOnline: Boolean, userAddress: String?){
&nbsp;        scope.launch {
&nbsp;            try {
&nbsp;                GlobalApp.GlobalUserRepo.conversationRepository.updateUserStatus(
&nbsp;                    userUuid = userUuid,
&nbsp;                    isOnline = isOnline,
&nbsp;                    userAddress = userAddress
&nbsp;                )
&nbsp;                Log.d(&quot;AppServer&quot;, &quot;Updated user $userUuid connection status: online=$isOnline, address=$userAddress&quot;)
&nbsp;            } catch (e: Exception){
&nbsp;                Log.e(&quot;AppServer&quot;, &quot;Failed to update user connection status&quot;, e)
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    fun markAllUsersOffline(){
&nbsp;        scope.launch {
&nbsp;            try {
&nbsp;                val allUsers = GlobalApp.GlobalUserRepo.userRepository.getAllConnectedUsers()
&nbsp;                for (user in allUsers) {
&nbsp;                    GlobalApp.GlobalUserRepo.conversationRepository.updateUserStatus(
&nbsp;                        userUuid = user.uuid,
&nbsp;                        isOnline = false,
&nbsp;                        userAddress = null
&nbsp;                    )
&nbsp;                }
&nbsp;                Log.d(&quot;AppServer&quot;, &quot;Marked all users as offline&quot;)
&nbsp;            } catch (e: Exception) {
&nbsp;                Log.e(&quot;AppServer&quot;, &quot;Failed to mark all users as offline&quot;, e)
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    // Stop the server and cancel any coroutine that are running within the CoroutineScope
&nbsp;    override fun close() {
&nbsp;        stop()
&nbsp;        scope.cancel()
&nbsp;    }
&nbsp;
&nbsp;    companion object {
&nbsp;        const val DEFAULT_PORT = 9614//MAIN HAD MODIFIED IT TO 9614 FROM 4242
&nbsp;        val CHAT_TYPE_PLAINTEXT = &quot;text/plain; charset=utf-8&quot;.toMediaType()
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-12-02 05:53</div>
</div>
</body>
</html>
